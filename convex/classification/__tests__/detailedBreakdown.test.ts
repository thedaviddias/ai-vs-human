import { describe, expect, it } from "vitest";
import { buildDetailedBreakdowns } from "../detailedBreakdown";

function makeCommit(overrides: Partial<Record<string, unknown>> = {}) {
  return {
    _id: "test" as never,
    _creationTime: Date.now(),
    repoId: "repo" as never,
    sha: "sha",
    message: "test",
    authoredAt: Date.now(),
    committedAt: Date.now(),
    classification: "human",
    ...overrides,
  };
}

describe("buildDetailedBreakdowns", () => {
  it("keeps specific AI tools as explicit entries", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "copilot", additions: 12 }),
    ] as never);

    expect(toolBreakdown).toEqual([
      { key: "github-copilot", label: "GitHub Copilot", commits: 1, additions: 12 },
    ]);
  });

  it("splits ai-assisted commits into concrete tools when detectable", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({
        classification: "ai-assisted",
        authorLogin: "coderabbitai[bot]",
        additions: 3,
      }),
      makeCommit({
        classification: "ai-assisted",
        message: "Generated by Qodo",
        additions: 5,
      }),
    ] as never);

    expect(toolBreakdown).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ key: "coderabbit", commits: 1 }),
        expect.objectContaining({ key: "qodo-merge", commits: 1 }),
      ])
    );
  });

  it("splits other-bot commits into concrete bots when detectable", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "other-bot", authorLogin: "codecov[bot]" }),
      makeCommit({ classification: "other-bot", authorLogin: "mergify[bot]" }),
    ] as never);

    expect(botBreakdown).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ key: "codecov", commits: 1 }),
        expect.objectContaining({ key: "mergify", commits: 1 }),
      ])
    );
  });

  it("falls back to explicit per-identity labels instead of grouping as others", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "other-bot", authorLogin: "internal-helper-bot[bot]" }),
    ] as never);

    expect(botBreakdown).toEqual([
      expect.objectContaining({
        key: "bot-internal-helper-bot",
        label: "Internal Helper Bot",
        commits: 1,
      }),
    ]);
  });

  it("maps v1 bot identity to Vercel Bot", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "other-bot", authorLogin: "v1[bot]" }),
    ] as never);

    expect(botBreakdown).toEqual([
      expect.objectContaining({
        key: "vercel",
        label: "Vercel Bot",
        commits: 1,
      }),
    ]);
  });

  it("uses explicit unknown labels when no strong signal is found", () => {
    const { toolBreakdown, botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "ai-assisted", coAuthors: ["Jane <jane@example.com>"] }),
      makeCommit({ classification: "other-bot", authorLogin: "" }),
    ] as never);

    expect(toolBreakdown).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ key: "ai-unspecified", label: "Unknown AI Assistant" }),
      ])
    );
    expect(botBreakdown).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ key: "bot-unspecified", label: "Unknown Automation Bot" }),
      ])
    );
  });

  it("accumulates multiple commits of the same AI tool", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "copilot", additions: 100 }),
      makeCommit({ classification: "copilot", additions: 250 }),
      makeCommit({ classification: "copilot", additions: 50 }),
    ] as never);

    expect(toolBreakdown).toEqual([
      { key: "github-copilot", label: "GitHub Copilot", commits: 3, additions: 400 },
    ]);
  });

  it("accumulates multiple commits of the same bot", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "dependabot" }),
      makeCommit({ classification: "dependabot" }),
      makeCommit({ classification: "dependabot" }),
    ] as never);

    expect(botBreakdown).toEqual([{ key: "dependabot", label: "Dependabot", commits: 3 }]);
  });

  it("accumulates same other-bot identity across multiple commits", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "other-bot", authorLogin: "codecov[bot]" }),
      makeCommit({ classification: "other-bot", authorLogin: "codecov[bot]" }),
    ] as never);

    expect(botBreakdown).toEqual([expect.objectContaining({ key: "codecov", commits: 2 })]);
  });

  it("ignores human commits entirely", () => {
    const { toolBreakdown, botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "human", additions: 500 }),
    ] as never);

    expect(toolBreakdown).toEqual([]);
    expect(botBreakdown).toEqual([]);
  });

  it("handles empty input", () => {
    const { toolBreakdown, botBreakdown } = buildDetailedBreakdowns([]);
    expect(toolBreakdown).toEqual([]);
    expect(botBreakdown).toEqual([]);
  });

  it("maps all fixed AI classifications correctly", () => {
    const classifications = [
      { classification: "copilot", key: "github-copilot" },
      { classification: "claude", key: "claude-code" },
      { classification: "cursor", key: "cursor" },
      { classification: "aider", key: "aider" },
      { classification: "devin", key: "devin" },
      { classification: "openai-codex", key: "openai-codex" },
      { classification: "gemini", key: "gemini" },
    ];

    const commits = classifications.map((c) => makeCommit({ classification: c.classification }));
    const { toolBreakdown } = buildDetailedBreakdowns(commits as never);

    for (const c of classifications) {
      expect(toolBreakdown.find((t) => t.key === c.key)).toBeDefined();
    }
    expect(toolBreakdown).toHaveLength(classifications.length);
  });

  it("maps all fixed automation classifications correctly", () => {
    const classifications = [
      { classification: "dependabot", key: "dependabot" },
      { classification: "renovate", key: "renovate" },
      { classification: "github-actions", key: "github-actions" },
    ];

    const commits = classifications.map((c) => makeCommit({ classification: c.classification }));
    const { botBreakdown } = buildDetailedBreakdowns(commits as never);

    for (const c of classifications) {
      expect(botBreakdown.find((b) => b.key === c.key)).toBeDefined();
    }
    expect(botBreakdown).toHaveLength(classifications.length);
  });

  it("sorts AI tools by commits descending, then additions descending", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "copilot", additions: 100 }),
      makeCommit({ classification: "claude", additions: 200 }),
      makeCommit({ classification: "claude", additions: 300 }),
    ] as never);

    // Claude: 2 commits, 500 additions → first
    // Copilot: 1 commit, 100 additions → second
    expect(toolBreakdown[0].key).toBe("claude-code");
    expect(toolBreakdown[1].key).toBe("github-copilot");
  });

  it("sorts bots by commits descending", () => {
    const { botBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "renovate" }),
      makeCommit({ classification: "dependabot" }),
      makeCommit({ classification: "dependabot" }),
      makeCommit({ classification: "dependabot" }),
    ] as never);

    expect(botBreakdown[0].key).toBe("dependabot");
    expect(botBreakdown[1].key).toBe("renovate");
  });

  it("defaults additions to 0 when undefined", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({ classification: "cursor" }),
    ] as never);

    expect(toolBreakdown[0].additions).toBe(0);
  });

  it("detects AI tools from co-authors in ai-assisted commits", () => {
    const { toolBreakdown } = buildDetailedBreakdowns([
      makeCommit({
        classification: "ai-assisted",
        coAuthors: ["copilot-swe-agent <copilot@github.com>"],
      }),
    ] as never);

    expect(toolBreakdown).toEqual(
      expect.arrayContaining([expect.objectContaining({ key: expect.stringContaining("copilot") })])
    );
  });
});
